1740769992800:import cats.*, cats.free.{ Trampoline => CatsTrampoline, * }, cats.arrow.*, cats.data.*, cats.syntax.all.*, cats.instances.all.*
1748335415562:import scala.util.parsing.combinator.JavaTokenParsers\ntype unit = Expr.Zero.type | Expr.One.type\nenum Expr[+T]:\n  case Add[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Sub[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Zero extends Expr[Nothing]\n  case Mul[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Div[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case One extends Expr[Nothing]\n  case Inv[+T](rhs: Expr[T]) extends Expr[T]\n  case Val[T](n: T) extends Expr[T]\nobject Expr extends JavaTokenParsers:\n  import Expr.*\n  def expr: Parser[Expr[Int | Double]] =\n    term ~ ("+"|"-") ~ term ^^ {\n      case lhs ~ "+" ~ rhs => Add(lhs, rhs)        \n      case lhs ~ "-" ~ rhs => Sub(lhs, rhs)        \n    } |\n    ("+"|"-") ~ term ^^ {\n      case "+" ~ rhs => Add(Zero, rhs)\n      case "-" ~ rhs => Sub(Zero, rhs)\n    } |\n    term\n\n  def term: Parser[Expr[Int | Double]] =\n    factor ~ ("*"|"/") ~ factor ^^ {\n      case lhs ~ "*" ~ rhs => Mul(lhs, rhs)        \n      case lhs ~ "/" ~ rhs => Div(lhs, rhs)        \n    } |\n    factor\n\n  def factor: Parser[Expr[Int | Double]] =\n    floatingPointNumber ^^ { n =>\n      try\n        n.toInt match\n          case 0 => Zero\n          case 1 => One\n          case n => Val(n)\n      catch _ =>\n        n.toDouble match\n          case 0d => Zero\n          case 1d => One\n          case n => Val(n)\n    } |\n    "("~> expr <~")"
1740769963223:import Expr.*
1740769969488:def eval(expr: Expr[Int | Double])(implicit unit: unit): Double =\n  expr match \n    case Zero => 0d\n    case One => 1d\n    case Val(n: Int) => n.toDouble\n    case Val(n: Double) => n\n    case Inv(n) if Zero eq unit => 0d - eval(n)\n    case Inv(n) if One eq unit => 1d / eval(n)\n    case Add(m, n) => eval(m) + eval(n)\n    case Sub(m, n) => eval(m) - eval(n)\n    case Mul(m, n) => eval(m) * eval(n)\n    case Div(m, n) => eval(m) / eval(n)
1741772689573:val swap: Expr ~> Expr =\n  new (Expr ~> Expr):\n    def apply[T](expr: Expr[T]): Expr[T] =\n      expr match\n        case Zero          => One\n        case One           => Zero\n        case Add(lhs, rhs) => Mul(apply(lhs), apply(rhs))\n        case Sub(lhs, rhs) => Div(apply(lhs), apply(rhs))\n        case Mul(lhs, rhs) => Add(apply(lhs), apply(rhs))\n        case Div(lhs, rhs) => Sub(apply(lhs), apply(rhs))\n        case Inv(lhs)      => Inv(apply(lhs))\n        case it            => it
1741766242930:parseAll(expr, "2*5+7*1*3")
