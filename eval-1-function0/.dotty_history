1744138842260:import cats._, cats.free._, cats.arrow._, Free._
1744138847109:case class Algorithms(n: Int, var counter: Int):\n  private def fibonacci(k: Int): Trampoline[Int] =\n    if k < 2\n    then\n      liftF { () => 1 min (0 max k) }\n    else\n      for\n        m <- fibonacci(k - 2)\n        n <- fibonacci(k - 1)\n      yield\n        n + m\n  private def factorial(k: Int): Trampoline[Int] =\n    if k < 1\n    then\n      liftF { () => 1 }\n    else\n      for\n        n <- factorial(k - 1)\n      yield\n        k * n\n  def fib: Trampoline[Int] = { counter = 0; fibonacci(n) }\n  def fac: Trampoline[Int] = { counter = 0; factorial(n) }
1744138852427:implicitly[Monad[Function0]]
1744138862080:class Function0ʹ[+R](f0: Function0[R]) extends Function0[R]:\n  override def apply(): R =\n    f0()\nobject Function0ʹ:\n  implicit val kittensFunction0ʹBimonad: Bimonad[Function0ʹ] =\n    new Bimonad[Function0ʹ]:\n      def extract[A](fa: Function0ʹ[A]): A = fa()\n\n      def coflatMap[A, B](fa: Function0ʹ[A])(f: Function0ʹ[A] => B): Function0ʹ[B] =\n        Function0ʹ(() => f(fa))\n\n      def pure[A](x: A): Function0ʹ[A] = Function0ʹ(() => x)\n\n      override def map[A, B](fa: Function0ʹ[A])(fn: A => B): Function0ʹ[B] =\n        Function0ʹ(() => fn(fa()))\n\n      override def map2[A, B, C](fa: Function0ʹ[A], fb: Function0ʹ[B])(fn: (A, B) => C): Function0ʹ[C] =\n        Function0ʹ(() => fn(fa(), fb()))\n\n      override def product[A, B](fa: Function0ʹ[A], fb: Function0ʹ[B]): Function0ʹ[(A, B)] =\n        Function0ʹ(() => (fa(), fb()))\n\n      override def ap[A, B](f: Function0ʹ[A => B])(fa: Function0ʹ[A]): Function0ʹ[B] =\n        Function0ʹ(() => f()(fa()))\n\n      def flatMap[A, B](fa: Function0ʹ[A])(f: A => Function0ʹ[B]): Function0ʹ[B] =\n        f(fa())\n\n      def tailRecM[A, B](a: A)(fn: A => Function0ʹ[Either[A, B]]): Function0ʹ[B] =\n        Function0ʹ(() => {\n          @annotation.tailrec\n          def loop(thisA: A): B =\n            fn(thisA)() match {\n              case Right(b)    => b\n              case Left(nextA) => loop(nextA)\n            }\n          loop(a)\n        })\n  def counting(implicit as: Algorithms): Function0 ~> Function0ʹ =\n    new (Function0 ~> Function0ʹ):\n      def apply[T](f0: Function0[T]): Function0ʹ[T] =\n        as.counter += 1\n        new Function0ʹ(f0)
1744138872091:implicit val as: Algorithms = Algorithms(20, 0)
1744138878827:as.fib.mapK(Function0ʹ.counting)
1744138916539:res1.runTailRec
1744138930482:res2()
1744138939275:as.counter
