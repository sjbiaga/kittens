1744202965234:enum Expr[+T]:\n  case Add[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Sub[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Zero extends Expr[Nothing]\n  case Mul[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Div[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case One extends Expr[Nothing]\n  case Inv[+T](rhs: Expr[T]) extends Expr[T]\n  case Val[T](n: T) extends Expr[T]
1744127504314:enum Op:\n  case Add, Sub, Mul, Div, Inv\nenum Tree[+T]:\n  val result: T\n  case Leaf[+T](override val result: T) extends Tree[T]\n  case Node[+T](override val result: T,\n                operator: Op,\n                left: Option[Tree[T]],\n                right: Option[Tree[T]]) extends Tree[T]
1744127510202:import Expr._
1744127512889:import Tree._
1744127518401:import cats._, cats.free._, cats.arrow._, Free._
1744127552689:import algebra.ring._
1744269360901:implicit val kittensExprMonad: Monad[Expr] =\n  new Monad[Expr]:\n    def pure[A](a: A): Expr[A] = Val(a)\n    override def flatten[A](fa: Expr[Expr[A]]): Expr[A] =\n      fa match\n        case Val(it)   => it\n        case Add(n, m) => Add(flatten(n), flatten(m))\n        case Sub(n, m) => Sub(flatten(n), flatten(m))\n        case Mul(n, m) => Mul(flatten(n), flatten(m))\n        case Div(n, m) => Div(flatten(n), flatten(m))\n        case Inv(n)    => Inv(flatten(n))\n        case it @ (Zero | One) => it\n    override def map[A, B](fa: Expr[A])(f: A => B): Expr[B] =\n      fa match\n        case Val(it)   => Val(f(it))\n        case Add(n, m) => Add(map(n)(f), map(m)(f))\n        case Sub(n, m) => Sub(map(n)(f), map(m)(f))\n        case Mul(n, m) => Mul(map(n)(f), map(m)(f))\n        case Div(n, m) => Div(map(n)(f), map(m)(f))\n        case Inv(n)    => Inv(map(n)(f))\n        case it @ (Zero | One) => it\n    def flatMap[A, B](fa: Expr[A])(f: A => Expr[B]): Expr[B] = // NOT stack safe!\n      flatten(map(fa)(f))\n    def tailRecM[A, B](a: A)(f: A => Expr[Either[A, B]]): Expr[B] = // stack safe!\n      def tailRecMʹ(a: A): Eval[Expr[B]] =\n        def loop(xe: Expr[Either[A, B]]): Eval[Expr[B]] =\n          xe match\n            case it @ (Zero | One) =>\n              Eval.now(it)\n            case Val(Left(a)) =>\n              for\n                _   <- Eval.Unit\n                xb <- tailRecMʹ(a)\n              yield\n                xb\n            case Val(Right(b)) =>\n              Eval.now(Val(b))\n            case Inv(xn) =>\n              for\n                n <- loop(xn)\n              yield\n                Inv(n)\n            case Add(xm, xn) =>\n              for\n                m <- loop(xm)\n                n <- loop(xn)\n              yield\n                Add(m, n)\n            case Sub(xm, xn) =>\n              for\n                m <- loop(xm)\n                n <- loop(xn)\n              yield\n                Sub(m, n)\n            case Mul(xm, xn) =>\n              for\n                m <- loop(xm)\n                n <- loop(xn)\n              yield\n                Mul(m, n)\n            case Div(xm, xn) =>\n              for\n                m <- loop(xm)\n                n <- loop(xn)\n              yield\n                Div(m, n)\n        loop(f(a))\n      tailRecMʹ(a).value
1744127554666:implicit def eval[A](expr: Expr[A])(implicit R: DivisionRing[A]): A =\n  expr match\n    case Zero      => R.zero\n    case One       => R.one\n    case Val(v)    => v\n    case Inv(n)    => R.negate(n)\n    case Add(m, n) => R.plus(m, n)\n    case Mul(m, n) => R.times(m, n)\n    case Sub(m, n) => R.minus(m, n)\n    case Div(m, n) => R.div(m, n)
1744207150074:def treeify(R: DivisionRing[?]): FunctionK[Expr, Tree] =\n  new FunctionK[Expr, Tree]:\n    def apply[A](xa: Expr[A]): Tree[A] =\n      implicit val Rʹ: DivisionRing[A] = R.asInstanceOf[DivisionRing[A]]\n      xa match\n        case Inv(n)    => Node(eval(xa), Op.Inv, None,           Some(apply(n)))\n        case Add(m, n) => Node(eval(xa), Op.Add, Some(apply(m)), Some(apply(n)))\n        case Mul(m, n) => Node(eval(xa), Op.Mul, Some(apply(m)), Some(apply(n)))\n        case Sub(m, n) => Node(eval(xa), Op.Sub, Some(apply(m)), Some(apply(n)))\n        case Div(m, n) => Node(eval(xa), Op.Div, Some(apply(m)), Some(apply(n)))\n        case _         => Leaf(eval(xa))
1744270722871:implicit val kittensTreeMonad: Monad[Tree] =\n  new Monad[Tree]:\n    def pure[A](a: A): Tree[A] = Leaf(a)\n    override def flatten[A](fa: Tree[Tree[A]]): Tree[A] = fa.result\n    override def map[A, B](fa: Tree[A])(f: A => B): Tree[B] =\n      fa match\n        case Leaf(a)                           => Leaf(f(a))\n        case Node(a, Op.Inv, _,       Some(n)) => Node(f(a), Op.Inv, None,            Some(map(n)(f)))\n        case Node(a, Op.Add, Some(m), Some(n)) => Node(f(a), Op.Add, Some(map(m)(f)), Some(map(n)(f)))\n        case Node(a, Op.Sub, Some(m), Some(n)) => Node(f(a), Op.Sub, Some(map(m)(f)), Some(map(n)(f)))\n        case Node(a, Op.Mul, Some(m), Some(n)) => Node(f(a), Op.Mul, Some(map(m)(f)), Some(map(n)(f)))\n        case Node(a, Op.Div, Some(m), Some(n)) => Node(f(a), Op.Div, Some(map(m)(f)), Some(map(n)(f)))\n    def flatMap[A, B](fa: Tree[A])(f: A => Tree[B]): Tree[B] = flatten(map(fa)(f))\n    // def tailRecM[A, B](a: A)(f: A => Tree[Either[A, B]]): Tree[B] = // NOT stack safe\n    //   flatMap(f(a))(_.fold(tailRecM(_)(f), pure))\n    def tailRecM[A, B](a: A)(f: A => Tree[Either[A, B]]): Tree[B] = // stack safe!\n      def tailRecMʹ(a: A): Eval[Tree[B]] =\n        def loop(te: Tree[Either[A, B]]): Eval[Tree[B]] =\n          te match\n            case Leaf(Left(a)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n              yield\n                Leaf(tb.result)\n            case Leaf(Right(b)) =>\n              Eval.now(Leaf(b))\n            case Node(Left(a), Op.Inv, _,        Some(tn)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n                n  <- loop(tn)\n              yield\n                Node(tb.result, Op.Inv, None, Some(n))\n            case Node(Right(b), Op.Inv, _,       Some(tn)) =>\n              for\n                _ <- Eval.Unit\n                n <- loop(tn)\n              yield\n                Node(b, Op.Inv, None, Some(n))\n            case Node(Left(a), Op.Add, Some(tm), Some(tn)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n                m  <- loop(tm)\n                n  <- loop(tn)\n              yield\n                Node(tb.result, Op.Add, Some(m), Some(n))\n            case Node(Right(b), Op.Add, Some(tm), Some(tn)) =>\n              for\n                _ <- Eval.Unit\n                m <- loop(tm)\n                n <- loop(tn)\n              yield\n                Node(b, Op.Add, Some(m), Some(n))\n            case Node(Left(a), Op.Sub, Some(tm), Some(tn)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n                m  <- loop(tm)\n                n  <- loop(tn)\n              yield\n                Node(tb.result, Op.Sub, Some(m), Some(n))\n            case Node(Right(b), Op.Sub, Some(tm), Some(tn)) =>\n              for\n                _ <- Eval.Unit\n                m <- loop(tm)\n                n <- loop(tn)\n              yield\n                Node(b, Op.Sub, Some(m), Some(n))\n            case Node(Left(a), Op.Mul, Some(tm), Some(tn)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n                m  <- loop(tm)\n                n  <- loop(tn)\n              yield\n                Node(tb.result, Op.Mul, Some(m), Some(n))\n            case Node(Right(b), Op.Mul, Some(tm), Some(tn)) =>\n              for\n                _ <- Eval.Unit\n                m <- loop(tm)\n                n <- loop(tn)\n              yield\n                Node(b, Op.Mul, Some(m), Some(n))\n            case Node(Left(a), Op.Div, Some(tm), Some(tn)) =>\n              for\n                _  <- Eval.Unit\n                tb <- tailRecMʹ(a)\n                m  <- loop(tm)\n                n  <- loop(tn)\n              yield\n                Node(tb.result, Op.Div, Some(m), Some(n))\n            case Node(Right(b), Op.Div, Some(tm), Some(tn)) =>\n              for\n                _ <- Eval.Unit\n                m <- loop(tm)\n                n <- loop(tn)\n              yield\n                Node(b, Op.Div, Some(m), Some(n))\n        loop(f(a))\n      tailRecMʹ(a).value
1744127571082:implicit val kittensIntRing: DivisionRing[Int] =\n  new DivisionRing[Int]:\n    override val zero = 0\n    override val one = 1\n    override def negate(n: Int) = 0 - n\n    override def reciprocal(n: Int) = ???\n    override def plus(m: Int, n: Int) = m + n\n    override def minus(m: Int, n: Int) = m - n\n    override def times(m: Int, n: Int) = m * n\n    override def div(m: Int, n: Int) = m / n
1744127848368:implicit def kittensExprRing[A]: DivisionRing[Expr[A]] =\n  new DivisionRing[Expr[A]]:\n    override val zero = Zero\n    override val one = One\n    override def negate(n: Expr[A]) = Inv(n)\n    override def reciprocal(n: Expr[A]) = ???\n    override def plus(m: Expr[A], n: Expr[A]) = Add(m, n)\n    override def minus(m: Expr[A], n: Expr[A]) = Sub(m, n)\n    override def times(m: Expr[A], n: Expr[A]) = Mul(m, n)\n    override def div(m: Expr[A], n: Expr[A]) = Div(m, n)
1744295935798:case class Algorithms(n: Int):\n  private def fibonacci(k: Int): Free[Expr, Expr[Int]] =\n    if k < 2\n    then\n      liftF { Val(if k < 1 then Zero else One) }\n    else\n      for\n        m <- defer { fibonacci(k - 2) }\n        n <- defer { fibonacci(k - 1) }\n      yield\n        Add(m, n)\n  private def factorial(k: Int): Free[Expr, Expr[Int]] =\n    if k < 1\n    then\n      liftF { Val(One) }\n    else\n      for\n        n <- defer { factorial(k - 1) }\n      yield\n        Mul(Val(k), n)\n  def fib: Free[Expr, Expr[Int]] = fibonacci(n)\n  def fac: Free[Expr, Expr[Int]] = factorial(n)
1744127617513:val as = Algorithms(10)
1744127818656:as.fib.mapK(treeify(kittensExprRing))
1744127856776:res0.runTailRec
1744127889856:kittensTreeMonad.map(res1)(eval)
1744128233239:res2.result
1744175427286:case class Algorithmsʹ(n: Int):\n  private def fibonacci(k: Int): Free[Tree, Tree[Expr[Int]]] =\n    if k < 2\n    then\n      liftF { Leaf(Leaf(if k < 1 then Zero else One)) }\n    else\n      for\n        m <- defer { fibonacci(k - 2) }\n        n <- defer { fibonacci(k - 1) }\n      yield\n        Node(Add(m.result, n.result), Op.Add, Some(m), Some(n))\n  private def factorial(k: Int): Free[Tree, Tree[Expr[Int]]] =\n    if k < 1\n    then\n      liftF { Leaf(Leaf(One)) }\n    else\n      for\n        n <- defer { factorial(k - 1) }\n      yield\n        Node(Mul(Val(k), n.result), Op.Mul, Some(Leaf(Val(k))), Some(n))\n  def fib: Free[Tree, Tree[Expr[Int]]] = fibonacci(n)\n  def fac: Free[Tree, Tree[Expr[Int]]] = factorial(n)
1744129447852:val asʹ = Algorithmsʹ(10)
1744129474115:asʹ.fac.runTailRec
1744130312290:kittensTreeMonad.flatten(res4)
1744131055576:kittensTreeMonad.map(res5)(eval)
1744131070216:res6.result
