1740690779355:import cats.*, cats.free.{ Trampoline => CatsTrampoline, * }, cats.arrow.*, cats.data.*, cats.syntax.all.*, cats.instances.all.*
1740690784530:import scala.util.control.TailCalls.TailRec
1740732132860:import cats.effect.unsafe.implicits.global, cats.effect.IO
1742069721385:sealed abstract trait Trampoline[A]:\n  import Trampoline.*\n\n  def visit[F[_]](v: Visitor[F]): F[A]\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  trait Visitor[F[_]] extends (Trampoline ~> F):\n    final override def apply[A](ta: Trampoline[A]): F[A] = ta.visit(this)\n\n    def done[A](value: A): F[A]\n    final def call[A](closure: Unit => Trampoline[A]): F[A] = fMap(Done(()), closure)\n    def fMap[A, B](self: Trampoline[A], cont: A => Trampoline[B]): F[B]\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  final case class Done[A](value: A) extends Trampoline[A]:\n    override def visit[F[_]](v: Visitor[F]): F[A] = v.done(value)\n\n  final case class Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]:\n    override def visit[F[_]](v: Visitor[F]): F[A] = v.call(closure)\n\n  final case class FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]:\n    override def visit[F[_]](v: Visitor[F]): F[B] = v.fMap(self, sequel)\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)\n\n  object Call:\n    def apply[A](thunk: => Trampoline[A]): Trampoline[A] = Call { _ => thunk }
1740742390036:import Trampoline.*
1748626923151:implicit val kittensTrampolineDeferInstance: Defer[Trampoline] =\n  new Defer[Trampoline]:\n    override def defer[A](fa: => Trampoline[A]): Trampoline[A] = Trampoline.Call(fa)
1748678845362:class MonadInterpreter[M[_]: Monad: Defer]:\n  val M = Monad[M]\n  val D = Defer[M]\n  object TrampolineInterpreter extends Trampoline.Visitor[M]:\n    override def done[A](value: A): M[A] = M.pure(value)\n    override def fMap[A, B](self: Trampoline[A], cont: A => Trampoline[B]): M[B] =\n      M.flatMap(D.defer(apply(self)))(cont andThen apply)
1740803117219:case object MaxSolutionsReached extends Throwable
1740803126667:type Coord[T] = (T, T)\nextension [T](row: T)\n  inline infix def x(col: T): Coord[T] = (row, col)\nextension [T](self: Coord[T])\n  inline def col: T = self._2\n  inline def row: T = self._1
1740805112351:case class Board(N: Int, private[Board] val squares: List[List[Boolean]]):\n  def this(squares: List[List[Boolean]]) = this(squares.size, squares)\n  require(squares.length == N && squares.forall(_.length == N))\n  def apply(i: Int)(j: Int): Boolean = squares(i)(j)\nimport scala.collection.mutable.Stack\ntype Point = Coord[Int]\ntype Solution = List[Point]\ntype PartialSolution = Stack[Point]\nimport scala.collection.Seq
1740805119031:class EmptyBoard(n: Int) extends Board(n, List.fill(n)(List.fill(n)(false))):\n  inline override def apply(i: Int)(j: Int): Boolean = false
1741322286666:given Board = new EmptyBoard(4)
1740805965846:import scala.util.control.NonLocalReturns.{ returning, throwReturn => thr }\n\nobject Validator:\n\n  def apply(solution: Seq[Point])\n           (using board: Board): Boolean = returning:\n    for\n      n <- 0 until board.N\n      m <- (n + 1) until board.N\n      p = solution(n)\n      q = solution(m)\n    do\n      if false ||\n        p.row == q.row ||\n        p.col == q.col ||\n        p.row - p.col == q.row - q.col ||\n        p.row + p.col == q.row + q.col ||\n        false\n      then\n        thr(false)\n    true
1741323451681:def queens[M[_]: Monad: Defer](using M: Long, board: Board): M[Unit] =\n  var maxSolutions = M\n  def tqueens(k: Int, q: Point)(implicit currentSolution: Solution): Trampoline[Unit] =\n    if q.row == board.N\n    then\n      Done(())\n    else if k == 0\n    then\n      if currentSolution.length == board.N && Validator(currentSolution)\n      then\n        println(currentSolution.sorted)\n        maxSolutions -= 1\n        if maxSolutions == 0\n        then\n          throw MaxSolutionsReached\n      Done(())\n    else if q.col == board.N\n    then\n      Call { tqueens(k, q.row + 1 x 0) }\n    else\n      for\n        _ <- Call { tqueens(k, q.row x q.col + 1) }\n        _ <- Call {\n          if !board(q.row)(q.col)\n          then\n            tqueens(k - 1, q.row x q.col + 1)(q :: currentSolution)\n          else\n            Done(())\n        }\n      yield\n        ()\n  val I = MonadInterpreter[M].TrampolineInterpreter\n  I.apply(kittensTrampolineDeferInstance.defer(tqueens(board.N, 0 x 0)(Nil)))
1741322992714:given Long = 2 // max number of solutions
1741323674953:def qEval = try queens[Eval].value catch MaxSolutionsReached => ()
1741323018434:def qTailRec = try queens[TailRec].result catch MaxSolutionsReached => ()
1741323031594:def qIO = try queens[IO].unsafeRunSync() catch MaxSolutionsReached => ()
1741323631177:def qCatsTrampoline = try { val f = queens[CatsTrampoline].runTailRec; f() } catch MaxSolutionsReached => ()
1742065577649:implicit val kittensTrampolineMonadInstance: Monad[Trampoline] =\n  new StackSafeMonad[Trampoline]:\n    //override def ap[A, B](ff: Trampoline[A => B])(fa: Trampoline[A]): Trampoline[B] =\n    //  flatMap(ff)(map(fa)(_))\n    //override def flatten[A](ffa: Trampoline[Trampoline[A]]): Trampoline[A] =\n    //  flatMap(ffa)(identity)\n    override def flatMap[A, B](fa: Trampoline[A])(fun: A => Trampoline[B]): Trampoline[B] =\n      fa.flatMap(fun)\n    //override def map[A, B](fa: Trampoline[A])(fun: A => B): Trampoline[B] =\n    //  fa.map(fun)\n    override def pure[A](a: A): Trampoline[A] = Trampoline.pure(a)
1741333236530:def qTrampoline = try queens[Trampoline]() catch MaxSolutionsReached => ()
1742140833250://def qId = try queens[Id] catch MaxSolutionsReached => ()
1741323676720:qEval
1741323643649:qTailRec
1741323639945:qIO
1741323636881:qCatsTrampoline
1741333239258:qTrampoline
1742140891778://qId
