1740771101332:import cats._, cats.free.{ Trampoline => CatsTrampoline, _}, cats.arrow._, cats.data._, cats.syntax.all._, cats.instances.all._
1741770236886:import scala.util.parsing.combinator.JavaTokenParsers\ntype unit = Expr.Zero.type | Expr.One.type\nenum Expr[+T]:\n  case Add[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Sub[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Zero extends Expr[Nothing]\n  case Mul[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Div[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case One extends Expr[Nothing]\n  case Inv[+T](rhs: Expr[T]) extends Expr[T]\n  case Val[T](n: T) extends Expr[T]\nobject Expr extends JavaTokenParsers:\n  import Expr._\n  def expr(implicit unit: unit): Parser[Expr[Int | Double]] =\n    term ~ rep(("+"|"-") ~ term) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "+" ~ rhs) => Add(lhs, rhs)\n        case (lhs, "-" ~ rhs) => Sub(lhs, rhs)\n      }\n    }\n\n  def term(implicit unit: unit): Parser[Expr[Int | Double]] =\n    factor ~ rep(("*"|"/") ~ factor) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "*" ~ rhs) => Mul(lhs, rhs)\n        case (lhs, "/" ~ rhs) => Div(lhs, rhs)\n      }\n    }\n\n  def factor(implicit unit: unit): Parser[Expr[Int | Double]] =\n    ("+"|"-") ~ literal ^^ {\n      case "-" ~ rhs if unit eq Zero => Inv(rhs)\n      case "+" ~ rhs => Add(Zero, rhs)\n      case "-" ~ rhs => Sub(Zero, rhs)\n    } |\n    literal ^^ { identity }\n\n  def literal(implicit unit: unit): Parser[Expr[Int | Double]] =\n    floatingPointNumber ^^ { it =>\n      it.toDouble match\n        case 0d => Zero\n        case 1d => One\n        case n => Val(n)\n    } |\n    decimalNumber ^^ { it =>\n      it.toInt match\n        case 0 => Zero\n        case 1 => One\n        case n => Val(n)\n    } |\n    "("~> expr <~")" ^^ { identity }\n\n  implicit class ExprInterpolator(private val sc: StringContext) extends AnyVal:\n    def x(args: Any*)(implicit unit: unit): Expr[Int | Double] =\n      val inp = (sc.parts zip (args :+ "")).foldLeft("") {\n        case (r, (p, a)) => r + p + a\n      }\n      parseAll(expr, inp) match\n        case Success(it, _) => it
1740771190014:import Expr._
1740771199838:def eval(expr: Expr[Int | Double])(implicit unit: unit): Double =\n  expr match \n    case Zero => 0d\n    case One => 1d\n    case Val(n: Int) => n.toDouble\n    case Val(n: Double) => n\n    case Inv(n) if Zero eq unit => 0d - eval(n)\n    case Inv(n) if One eq unit => 1d / eval(n)\n    case Add(m, n) => eval(m) + eval(n)\n    case Sub(m, n) => eval(m) - eval(n)\n    case Mul(m, n) => eval(m) * eval(n)\n    case Div(m, n) => eval(m) / eval(n)
1740771205959:val swap: unit ?=> Expr ~> Expr =\n  new (Expr ~> Expr):\n    def apply[T](expr: Expr[T]): Expr[T] =\n      expr match\n        case Zero          => One\n        case One           => Zero\n        case Add(lhs, rhs) => Mul(apply(lhs), apply(rhs))\n        case Sub(lhs, rhs) => Div(apply(lhs), apply(rhs))\n        case Mul(lhs, rhs) => Add(apply(lhs), apply(rhs))\n        case Div(lhs, rhs) => Sub(apply(lhs), apply(rhs))\n        case Inv(Zero)\n          if summon[unit] eq One => apply(Div(One, Zero))\n        case Inv(rhs)      => Inv(apply(rhs))\n        case it            => it
1741778308095:final case class Builder[T](lhs: Expr[T], private var save: List[Expr[T]]):\n  def swapping(implicit unit: unit) = Builder(swap(lhs), save)\n  def add(rhs: Expr[T], n: Int = 1) = Builder(List.fill(1 max n)(rhs).foldLeft(lhs)(Add(_, _)), save)\n  def subtract(rhs: Expr[T], n: Int = 1) = Builder(List.fill(1 max n)(rhs).foldLeft(lhs)(Sub(_, _)), save)\n  def multiply(rhs: Expr[T], n: Int = 1) = Builder(List.fill(1 max n)(rhs).foldLeft(lhs)(Mul(_, _)), save)\n  def divide(rhs: Expr[T], n: Int = 1) = Builder(List.fill(1 max n)(rhs).foldLeft(lhs)(Div(_, _)), save)\n  def invert(n: Int = 1): Builder[T] = Builder(List.fill(1 max n)(()).foldLeft(lhs) { (it, _) => Inv(it) }, save)\n  def open = Builder.From(lhs :: save)\n  def close(f: (Builder[T], Expr[T]) => Builder[T], invert: Int = 0) =\n    Builder(f(Builder(save.head, Nil), lhs).invert(invert).lhs, save.tail)\nobject Builder:\n  def start[T] = From[T](Nil)\n  final case class From[T](save: List[Expr[T]]):\n    def apply(lhs: Expr[T]): Builder[T] = Builder(lhs, save)
1740771209246:given unit = One
1740747053767:given unit = Zero
1742223912881:implicit def kittensExprMonoidK(implicit unit: unit): MonoidK[Expr] =\n  new MonoidK[Expr]:\n    def empty[A]: Expr[A] = unit.asInstanceOf[Expr[A]]\n    def combineK[A](x: Expr[A], y: Expr[A]): Expr[A] =\n      unit match\n        case Zero => Add(x, y)\n        case One  => Mul(x, y)
1740837174989:Builder.start(x"0")\n  .add(One)\n  .multiply(Val(5d), 4)\n    .open(One)\n    .add(One, 2)\n    .close(_.add(_))\n  .lhs
1740837179452:Builder.start(x"0")\n  .add(One)\n  .multiply(Val(5d), 4)\n    .open(One)\n    .add(One, 2)\n    .close(_.add(_))\n  .swapping\n  .lhs
1740837185700:res0 <+> res1
1741262152975:given Monoid[Expr[Int | Double]] = MonoidK[Expr].algebra[Int | Double]
1741262157905:res0 |+| res1
1741262186544:eval(res0 |+| res1)
1741262190055:eval(res0 <+> res1)
