1740769581608:import cats._, cats.free.{ Trampoline => CatsTrampoline, _}, cats.arrow._, cats.data._, cats.syntax.all._, cats.instances.all._
1741770236886:import scala.util.parsing.combinator.JavaTokenParsers\ntype unit = Expr.Zero.type | Expr.One.type\nenum Expr[+T]:\n  case Add[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Sub[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Zero extends Expr[Nothing]\n  case Mul[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Div[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case One extends Expr[Nothing]\n  case Inv[+T](rhs: Expr[T]) extends Expr[T]\n  case Val[T](n: T) extends Expr[T]\nobject Expr extends JavaTokenParsers:\n  import Expr._\n  def expr(implicit unit: unit): Parser[Expr[Int | Double]] =\n    term ~ rep(("+"|"-") ~ term) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "+" ~ rhs) => Add(lhs, rhs)\n        case (lhs, "-" ~ rhs) => Sub(lhs, rhs)\n      }\n    }\n\n  def term(implicit unit: unit): Parser[Expr[Int | Double]] =\n    factor ~ rep(("*"|"/") ~ factor) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "*" ~ rhs) => Mul(lhs, rhs)\n        case (lhs, "/" ~ rhs) => Div(lhs, rhs)\n      }\n    }\n\n  def factor(implicit unit: unit): Parser[Expr[Int | Double]] =\n    ("+"|"-") ~ literal ^^ {\n      case "-" ~ rhs if unit eq Zero => Inv(rhs)\n      case "+" ~ rhs => Add(Zero, rhs)\n      case "-" ~ rhs => Sub(Zero, rhs)\n    } |\n    literal\n\n  def literal(implicit unit: unit): Parser[Expr[Int | Double]] =\n    floatingPointNumber ^^ {\n      _.toDouble match\n        case 0d => Zero\n        case 1d => One\n        case n => Val(n)\n    } |\n    decimalNumber ^^ {\n      _.toInt match\n        case 0 => Zero\n        case 1 => One\n        case n => Val(n)\n    } |\n    "("~> expr <~")"\n\n  implicit class ExprInterpolator(private val sc: StringContext) extends AnyVal:\n    def x(args: Any*)(implicit unit: unit): Expr[Int | Double] =\n      val inp = (sc.parts zip (args :+ "")).foldLeft("") {\n        case (r, (p, a)) => r + p + a\n      }\n      parseAll(expr, inp).get
1740769626071:import Expr._
1741074718934:implicit val kittensExprFunctor: Functor[Expr] =\n  new Functor[Expr]:\n    def map[A, B](xa: Expr[A])(f: A => B): Expr[B] =\n      xa match\n        case Val(a)        => Val(f(a))\n        case Inv(rhs)      => Inv(map(rhs)(f))\n        case Add(lhs, rhs) => Add(map(lhs)(f), map(rhs)(f))\n        case Sub(lhs, rhs) => Sub(map(lhs)(f), map(rhs)(f))\n        case Mul(lhs, rhs) => Mul(map(lhs)(f), map(rhs)(f))\n        case Div(lhs, rhs) => Div(map(lhs)(f), map(rhs)(f))\n        case it @ ( Zero | One ) => it
1741080775999:implicit val kittensExprCoflatMap: CoflatMap[Expr] =\n  new CoflatMap[Expr]:\n    def map[A, B](xa: Expr[A])(f: A => B): Expr[B] = kittensExprFunctor.map(xa)(f)\n    override def coflatten[A](xa: Expr[A]): Expr[Expr[A]] =\n      xa match\n        case it @ Val(_)       => Val(it)\n        case Inv(rhs)          => Inv(coflatten(rhs))\n        case Add(lhs, rhs)     => Add(coflatten(lhs), coflatten(rhs))\n        case Sub(lhs, rhs)     => Sub(coflatten(lhs), coflatten(rhs))\n        case Mul(lhs, rhs)     => Mul(coflatten(lhs), coflatten(rhs))\n        case Div(lhs, rhs)     => Div(coflatten(lhs), coflatten(rhs))\n        case it @ (Zero | One) => it\n    def coflatMap[A, B](xa: Expr[A])(f: Expr[A] => B): Expr[B] =\n      map(coflatten(xa))(f)
1740769631560:def eval(expr: Expr[Int | Double])(implicit unit: unit): Double =\n  expr match \n    case Zero => 0d\n    case One => 1d\n    case Val(n: Int) => n.toDouble\n    case Val(n: Double) => n\n    case Inv(n) if Zero eq unit => 0d - eval(n)\n    case Inv(n) if One eq unit => 1d / eval(n)\n    case Add(m, n) => eval(m) + eval(n)\n    case Sub(m, n) => eval(m) - eval(n)\n    case Mul(m, n) => eval(m) * eval(n)\n    case Div(m, n) => eval(m) / eval(n)
1740771205959:val swap: unit ?=> Expr ~> Expr =\n  new (Expr ~> Expr):\n    def apply[T](expr: Expr[T]): Expr[T] =\n      expr match\n        case Zero          => One\n        case One           => Zero\n        case Add(lhs, rhs) => Mul(apply(lhs), apply(rhs))\n        case Sub(lhs, rhs) => Div(apply(lhs), apply(rhs))\n        case Mul(lhs, rhs) => Add(apply(lhs), apply(rhs))\n        case Div(lhs, rhs) => Sub(apply(lhs), apply(rhs))\n        case Inv(Zero)\n          if summon[unit] eq One => apply(Div(One, Zero))\n        case Inv(rhs)      => Inv(apply(rhs))\n        case it            => it
1741080423806:given unit = One
1741080907686:kittensExprCoflatMap.coflatten(Inv(Mul(One, Add(Val(1), Zero))))
1741080928886:kittensExprCoflatMap.coflatMap(Inv(Mul(One, Add(Val(1), Zero))))(eval)
1741080989718://eval(kittensExprCoflatMap.coflatten(Inv(Mul(One, Add(Val(1), Zero)))))
1741089373573:def evalʹ(expr: Expr[Int => Int]): Int => Int =\n  expr match \n    case Zero      => Function.const(0)\n    case One       => Function.const(1)\n    case Val(f)    => f\n    case Inv(n)    => { k => -evalʹ(n).apply(k) }\n    case Add(m, n) => { k => evalʹ(m).apply(k) + evalʹ(n).apply(k) }\n    case Sub(m, n) => { k => evalʹ(m).apply(k) - evalʹ(n).apply(k) }\n    case Mul(m, n) => { k => evalʹ(m).apply(k) * evalʹ(n).apply(k) }\n    case Div(m, n) => { k => evalʹ(m).apply(k) / evalʹ(n).apply(k) }
1741116202470:def evalʹ(expr: Expr[Double => Double]): unit ?=> (Double => Double) =\n  expr match \n    case Zero      => Function.const(0d)\n    case One       => Function.const(1d)\n    case Val(f)    => f\n    case Inv(n) if summon[unit] eq Zero => { k => -evalʹ(n).apply(k) }\n    case Inv(n) if summon[unit] eq One  => { k => 1d / evalʹ(n).apply(k) }\n    case Add(m, n) => { k => evalʹ(m).apply(k) + evalʹ(n).apply(k) }\n    case Sub(m, n) => { k => evalʹ(m).apply(k) - evalʹ(n).apply(k) }\n    case Mul(m, n) => { k => evalʹ(m).apply(k) * evalʹ(n).apply(k) }\n    case Div(m, n) => { k => evalʹ(m).apply(k) / evalʹ(n).apply(k) }
1741088857215:kittensExprCoflatMap.coflatten(Inv(Mul(Val((_: Double).+(1)), Add(Val((_: Double).*(0)), Val((_: Double).-(1))))))
1741088866807:kittensExprCoflatMap.coflatMap(Inv(Mul(Val((_: Double).+(1)), Add(Val((_: Double).*(0)), Val((_: Double).-(1))))))(evalʹ)
1741089430372:res3.map(_(0d))
1741089436108:eval(res4)
1742117634838:evalʹ(Inv(Mul(Val((_: Double).+(1)), Add(Val((_: Double).*(0)), Val((_: Double).-(1))))))
