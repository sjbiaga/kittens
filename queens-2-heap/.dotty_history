1740803106252:sealed abstract trait Heap:\n  protected def apply(): Option[Heap]\n  @annotation.tailrec\n  final def call: Unit =\n    this() match\n      case Some(heap) => heap.call\n      case _ =>\n\nobject Heap:\n  case object Done extends Heap:\n    override protected def apply(): Option[Heap] = None\n\n  final case class Call(closure: Unit => Heap) extends Heap:\n    override protected def apply(): Option[Heap] = Some(closure(()))\n\n  object Call:\n    inline def apply(thunk: => Heap): Call = new Call(_ => thunk)\n\n  final case class More(calls: Heap*) extends Heap:\n    override protected def apply(): Option[Heap] = calls\n      .headOption\n      .map {\n        _() match\n          case Some(it: More) => More((it.calls ++ calls.tail)*)\n          case Some(it: Call) => More((it +: calls.tail)*)\n          case _ => More(calls.tail*)\n      }
1740803186034:import Heap._
1740803117219:case object MaxSolutionsReached extends Throwable
1740803126667:type Coord[T] = (T, T)\nextension [T](row: T)\n  inline infix def x(col: T): Coord[T] = (row, col)\nextension [T](self: Coord[T])\n  inline def col: T = self._2\n  inline def row: T = self._1
1740805112351:case class Board(N: Int, private[Board] val squares: List[List[Boolean]]):\n  def this(squares: List[List[Boolean]]) = this(squares.size, squares)\n  require(squares.length == N && squares.forall(_.length == N))\n  def apply(i: Int)(j: Int): Boolean = squares(i)(j)\nimport scala.collection.mutable.Stack\ntype Point = Coord[Int]\ntype Solution = List[Point]\ntype PartialSolution = Stack[Point]\nimport scala.collection.Seq
1740805119031:class EmptyBoard(n: Int) extends Board(n, List.fill(n)(List.fill(n)(false))):\n  inline override def apply(i: Int)(j: Int): Boolean = false
1740803141211:import scala.util.control.NonLocalReturns.{ returning, throwReturn => thr }\n\nobject Validator:\n\n  def apply(solution: Seq[Point])\n           (using board: Board): Boolean = returning:\n    for\n      n <- 0 until board.N\n      m <- (n + 1) until board.N\n      p = solution(n)\n      q = solution(m)\n    do\n      if false ||\n        p.row == q.row ||\n        p.col == q.col ||\n        p.row - p.col == q.row - q.col ||\n        p.row + p.col == q.row + q.col ||\n        false\n      then\n        thr(false)\n    true
1740803262267:def queens(using M: Long, board: Board): Unit =\n  var maxSolutions = M\n  Call { hqueens(board.N, 0 x 0)(Nil) }.call\n  def hqueens(k: Int, q: Point)(implicit currentSolution: Solution): Heap =\n    if q.row == board.N\n    then\n      Done\n    else if k == 0\n    then\n      if Validator(currentSolution)\n      then\n        println(currentSolution.sorted)\n        maxSolutions -= 1\n        if maxSolutions == 0\n        then\n          throw MaxSolutionsReached\n      Done\n    else if q.col == board.N\n    then\n      Call { hqueens(k, q.row + 1 x 0) }\n    else\n      More (\n        Call { hqueens(k, q.row x q.col + 1) }\n      , if !board(q.row)(q.col)\n        then\n          Call { hqueens(k - 1, q.row x q.col + 1)(currentSolution :+ q) }\n        else\n          Done\n      )
1740805129471:given Board = new EmptyBoard(4)
1741709758926:given Long = 2
1740803267018:try queens catch MaxSolutionsReached => ()
