1740774628434:import cats._, cats.arrow._, cats.free.{ Trampoline => CatsTrampoline, _ }
1740774636295:sealed abstract trait Trampoline[+A]:\n  import Trampoline._\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  final case class Done[+A](value: A) extends Trampoline[A]\n\n  final case class Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n\n  final case class FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)\n\n  object Call:\n    def apply[A](thunk: => Trampoline[A]): Trampoline[A] = Call { _ => thunk }
1740774640300:import Trampoline._
1740774645708:def fibonacci(k: Int): Trampoline[Int] =\n  if k < 2\n  then\n    Done(1 min (0 max k))\n  else\n    for\n      m <- Call { fibonacci(k - 2) }\n      n <- Call { fibonacci(k - 1) }\n    yield\n      n + m
1740773797109:val kittensTrampolineToCatsEval: Trampoline ~> Eval =\n  new FunctionK[Trampoline, Eval]:\n    def apply[A](ta: Trampoline[A]): Eval[A] =\n      ta match\n        case Done(a) => Eval.now(a)\n        case Call(g) => Eval.defer(apply(g(())))\n        case FlatMap(s, g) => Eval.defer(apply(s)).flatMap(g andThen apply)
1740773809620:kittensTrampolineToCatsEval.apply(fibonacci(15)).value
1740774650596:val kittensTrampolineToCatsTrampoline: Trampoline ~> CatsTrampoline =\n  new FunctionK[Trampoline, CatsTrampoline]:\n    def apply[A](ta: Trampoline[A]): CatsTrampoline[A] =\n      ta match\n        case Done(a) => Free.pure(a)\n        case Call(g) => Free.defer(apply(g(())))\n        case FlatMap(s, g) => Free.defer(apply(s)).flatMap(g andThen apply)
1740774653884:kittensTrampolineToCatsTrampoline.apply(fibonacci(15)).runTailRec()()
1740774659563:import scala.util.control.TailCalls.{ TailRec, tailcall, done }
1740774667044:val kittensTrampolineToTailRec: Trampoline ~> TailRec =\n  new FunctionK[Trampoline, TailRec]:\n    def apply[A](ta: Trampoline[A]): TailRec[A] =\n      ta match\n        case Done(a) => done(a)\n        case Call(g) => tailcall(apply(g(())))\n        case FlatMap(s, g) => tailcall(apply(s)).flatMap(g andThen apply)
1740773953516:kittensTrampolineToTailRec.apply(fibonacci(15)).result
1748623152412:def rec(n: Int): Trampoline[Int] = if n == 0 then Done(0) else rec(n-1).flatMap(rec)
1748623178772:kittensTrampolineToCatsEval.apply(rec(10000)).value
1748623348452:kittensTrampolineToCatsTrampoline.apply(rec(10000)).runTailRec()()
1748623380324:kittensTrampolineToTailRec.apply(rec(10000)).result
