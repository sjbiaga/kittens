1741009151712:import algebra.ring._
1741770236886:import scala.util.parsing.combinator.JavaTokenParsers\ntype unit = Expr.Zero.type | Expr.One.type\nenum Expr[+T]:\n  case Add[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Sub[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Zero extends Expr[Nothing]\n  case Mul[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case Div[+T](lhs: Expr[T], rhs: Expr[T]) extends Expr[T]\n  case One extends Expr[Nothing]\n  case Inv[+T](rhs: Expr[T]) extends Expr[T]\n  case Val[T](n: T) extends Expr[T]\nobject Expr extends JavaTokenParsers:\n  import Expr._\n  def expr(implicit unit: unit): Parser[Expr[Int | Double]] =\n    term ~ rep(("+"|"-") ~ term) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "+" ~ rhs) => Add(lhs, rhs)\n        case (lhs, "-" ~ rhs) => Sub(lhs, rhs)\n      }\n    }\n\n  def term(implicit unit: unit): Parser[Expr[Int | Double]] =\n    factor ~ rep(("*"|"/") ~ factor) ^^ {\n      case lhs ~ rhs => rhs.foldLeft(lhs) {\n        case (lhs, "*" ~ rhs) => Mul(lhs, rhs)\n        case (lhs, "/" ~ rhs) => Div(lhs, rhs)\n      }\n    }\n\n  def factor(implicit unit: unit): Parser[Expr[Int | Double]] =\n    ("+"|"-") ~ literal ^^ {\n      case "-" ~ rhs if unit eq Zero => Inv(rhs)\n      case "+" ~ rhs => Add(Zero, rhs)\n      case "-" ~ rhs => Sub(Zero, rhs)\n    } |\n    literal\n\n  def literal(implicit unit: unit): Parser[Expr[Int | Double]] =\n    floatingPointNumber ^^ { n =>\n      try\n        n.toInt match\n          case 0 => Zero\n          case 1 => One\n          case n => Val(n)\n      catch _ =>\n        n.toDouble match\n          case 0d => Zero\n          case 1d => One\n          case n => Val(n)\n    } |\n    "("~> expr <~")"\n\n  implicit class ExprInterpolator(private val sc: StringContext) extends AnyVal:\n    def x(args: Any*)(implicit unit: unit): Expr[Int | Double] =\n      val inp = (sc.parts zip (args :+ "")).foldLeft("") {\n        case (r, (p, a)) => r + p + a\n      }\n      parseAll(expr, inp).get
1741009493391:enum Op:\n  case Add, Sub, Mul, Div, Inv\nenum Tree[T]:\n  val result: T\n  case Leaf[T](override val result: T) extends Tree[T]\n  case Node[T](override val result: T,\n               operator: Op,\n               left: Option[Tree[T]],\n               right: Option[Tree[T]]) extends Tree[T]
1741009169472:import Expr._\nimport Tree._
1741009177216:type Id[T] = T\ntrait FunctionKʹ[R[_], F[_], G[_]]:\n  def apply[A: R](fa: F[A]): G[A]\ntype FunctionK[F[_], G[_]] = FunctionKʹ[Id, F, G]\ntype ~>[F[_], G[_]] = FunctionK[F, G]
1741009199264:implicit def id[T]: Id[T] = null.asInstanceOf[Id[T]]
1740771205959:val swap: unit ?=> Expr ~> Expr =\n  new (Expr ~> Expr):\n    def apply[T: Id](expr: Expr[T]): Expr[T] =\n      expr match\n        case Zero          => One\n        case One           => Zero\n        case Add(lhs, rhs) => Mul(apply(lhs), apply(rhs))\n        case Sub(lhs, rhs) => Div(apply(lhs), apply(rhs))\n        case Mul(lhs, rhs) => Add(apply(lhs), apply(rhs))\n        case Div(lhs, rhs) => Sub(apply(lhs), apply(rhs))\n        case Inv(Zero)\n          if summon[unit] eq One => apply(Div(One, Zero))\n        case Inv(rhs)      => Inv(apply(rhs))\n        case it            => it
1745816065989:final case class Builder[T](lhs: Expr[T], private var save: List[Expr[T]]):\n  def fill(n: Int)(rhs: Expr[T]) = List.fill(0 max n)(rhs)\n  def swapping(implicit unit: unit) = Builder(swap(lhs), save)\n  def add(rhs: Expr[T], n: Int = 1) = Builder(fill(n)(rhs).foldLeft(lhs)(Add(_, _)), save)\n  def subtract(rhs: Expr[T], n: Int = 1) = Builder(fill(n)(rhs).foldLeft(lhs)(Sub(_, _)), save)\n  def multiply(rhs: Expr[T], n: Int = 1) = Builder(fill(n)(rhs).foldLeft(lhs)(Mul(_, _)), save)\n  def divide(rhs: Expr[T], n: Int = 1) = Builder(fill(n)(rhs).foldLeft(lhs)(Div(_, _)), save)\n  def invert(n: Int = 1): Builder[T] = Builder(List.fill(0 max n)(()).foldLeft(lhs) { (lhs, _) => Inv(lhs) }, save)\n  def open = Builder.From(lhs :: save)\n  def close(f: (Builder[T], Expr[T]) => Builder[T], invert: Int = 0) =\n    val self = Builder(save.head, save.tail)\n    f(self, lhs).invert(invert)\nobject Builder:\n  def start[T] = From[T](Nil)\n  final case class From[T](save: List[Expr[T]]):\n    def apply(lhs: Expr[T]): Builder[T] = Builder(lhs, save)
1741009229848:implicit val kittensDoubleRing: Ring[Double] =\n  new DivisionRing[Double]:\n    override val zero = 0d\n    override val one = 1d\n    override def negate(n: Double) = 0d - n\n    override def reciprocal(n: Double) = 1d / n\n    override def plus(m: Double, n: Double) = m + n\n    override def minus(m: Double, n: Double) = m - n\n    override def times(m: Double, n: Double) = m * n\n    override def div(m: Double, n: Double) = m / n
1741009237992:implicit def evalʹ[A](expr: Expr[A])(implicit R: DivisionRing[A], unit: unit): A =\n  expr match \n    case Zero      => R.zero\n    case One       => R.one\n    case Val(v)    => v\n    case Inv(n) if unit eq Zero => R.negate(n)\n    case Inv(n) if unit eq One  => R.reciprocal(n)\n    case Add(m, n) => R.plus(m, n)\n    case Mul(m, n) => R.times(m, n)\n    case Sub(m, n) => R.minus(m, n)\n    case Div(m, n) => R.div(m, n)
1742145214294:val eval: unit ?=> FunctionKʹ[Ring, Expr, Tree] =\n  new FunctionKʹ[Ring, Expr, Tree]:\n    def apply[A: Ring](xa: Expr[A]): Tree[A] =\n      given DivisionRing[A] = implicitly[Ring[A]].asInstanceOf[DivisionRing[A]]\n      xa match\n        case Inv(n)    => Node(evalʹ(xa), Op.Inv, None, Some(apply(n)))\n        case Add(m, n) => Node(evalʹ(xa), Op.Add, Some(apply(m)), Some(apply(n)))\n        case Mul(m, n) => Node(evalʹ(xa), Op.Mul, Some(apply(m)), Some(apply(n)))\n        case Sub(m, n) => Node(evalʹ(xa), Op.Sub,  Some(apply(m)), Some(apply(n)))\n        case Div(m, n) => Node(evalʹ(xa), Op.Div, Some(apply(m)), Some(apply(n)))\n        case         _ => Leaf(evalʹ(xa))
1742227028640:val eval: unit ?=> FunctionKʹ[Ring, Expr, Tree] =\n  new FunctionKʹ[Ring, Expr, Tree]:\n    def apply[A: Ring](xa: Expr[A]): Tree[A] =\n      given DivisionRing[A] = implicitly[Ring[A]].asInstanceOf[DivisionRing[A]]\n      def evalʹ(xa: Expr[A]): Tree[A] =\n        xa match\n          case Inv(n)    =>\n            val rhs = evalʹ(n)\n            val i = summon[unit] match\n              case Zero => given_DivisionRing_A.negate(rhs.result)\n              case One  => given_DivisionRing_A.reciprocal(rhs.result)\n            Node(i, Op.Inv, None, Some(rhs))\n          case Add(m, n) =>\n            val (lhs, rhs) = evalʹ(m) -> evalʹ(n)\n            val s = given_DivisionRing_A.plus(lhs.result, rhs.result)\n            Node(s, Op.Add, Some(lhs), Some(rhs))\n          case Sub(m, n) =>\n            val (lhs, rhs) = evalʹ(m) -> evalʹ(n)\n            val d = given_DivisionRing_A.minus(lhs.result, rhs.result)\n            Node(d, Op.Sub, Some(lhs), Some(rhs))\n          case Mul(m, n) =>\n            val (lhs, rhs) = evalʹ(m) -> evalʹ(n)\n            val p = given_DivisionRing_A.times(lhs.result, rhs.result)\n            Node(p, Op.Mul, Some(lhs), Some(rhs))\n          case Div(m, n) =>\n            val (lhs, rhs) = evalʹ(m) -> evalʹ(n)\n            val q = given_DivisionRing_A.div(lhs.result, rhs.result)\n            Node(q, Op.Div, Some(lhs), Some(rhs))\n          case Zero      =>\n            Leaf(given_DivisionRing_A.zero)\n          case One       =>\n            Leaf(given_DivisionRing_A.one)\n          case Val(r)    =>\n            Leaf(r)\n      evalʹ(xa)
1741009863055:given unit = One
1741009568527:Builder.start(x"0")\n  .add(One)\n  .multiply(Val(5d), 4)\n    .open(One)\n    .add(One, 2)\n    .close(_.add(_))\n  .swapping\n  .lhs
1741009571183:res0.asInstanceOf[Expr[Double]]
1741009574183:eval(res1)
