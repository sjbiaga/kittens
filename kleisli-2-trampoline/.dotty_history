1740690779355:import cats._, cats.free.{ Trampoline => CatsTrampoline, _}, cats.arrow._, cats.data._, cats.syntax.all._, cats.instances.all._
1742159651094:type Kleisliʹ[A, B] = Kleisli[Trampoline, A, B]\nenum Trampoline[+A]:\n  case Done[+A](value: A) extends Trampoline[A]\n  case Call[A](closure: Kleisliʹ[Unit, A]) extends Trampoline[A]\n  case FlatMap[A, B](self: Trampoline[A], sequel: Kleisliʹ[A, B]) extends Trampoline[B]\n\n  import Trampoline._\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, Kleisli(sequel))\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure.run(())()\n    case FlatMap(Done(value), sequel) => sequel.run(value)()\n    case FlatMap(Call(closure), sequel) => (closure andThen sequel).run(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel andThen sequel)()\n\nobject Trampoline:\n\n  implicit val kittensTrampolineFlatMapInstance: cats.FlatMap[Trampoline] =\n    new StackSafeMonad[Trampoline]:\n      def pure[A](a: A): Trampoline[A] =\n        Trampoline.Done(a)\n      def flatMap[A, B](fa: Trampoline[A])(f: A => Trampoline[B]): Trampoline[B] =\n        Trampoline.FlatMap(fa, Kleisli(f))\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)\n  \n  object Call:\n    def apply[A](thunk: => Trampoline[A]): Trampoline[A] = Call(Kleisli(_ => thunk))
1740742390036:import Trampoline._
1741640532181:def fibonacci(k: Int): Trampoline[Int] =\n  if k < 2\n  then\n    Done(1 min (0 max k))\n  else\n    for\n      m <- Call { fibonacci(k - 2) }\n      n <- Call { fibonacci(k - 1) }\n    yield\n      n + m
1742157584853:val nat: Trampoline ~> Eval =\n  new FunctionK[Trampoline, Eval]:\n    def apply[A](ta: Trampoline[A]): Eval[A] =\n      ta match\n        case Done(a) => Eval.now(a)\n        case Call(g) => Eval.defer(apply(g.run(())))\n        case FlatMap(s, g) => apply(s).flatMap(g.run andThen apply)
1742157597916:nat.apply(fibonacci(15)).value
