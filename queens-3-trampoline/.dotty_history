1740805921544:enum Trampoline[+A]:\n  case Done[+A](value: A) extends Trampoline[A]\n  case Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n  case FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)\n\n  object Call:\n    inline def apply[A](closure: => Trampoline[A]): Trampoline[A] = new Call(_ => closure)
1740804809095:import Trampoline.*
1740803117219:case object MaxSolutionsReached extends Throwable
1740803126667:type Coord[T] = (T, T)\nextension [T](row: T)\n  inline infix def x(col: T): Coord[T] = (row, col)\nextension [T](self: Coord[T])\n  inline def col: T = self._2\n  inline def row: T = self._1
1740805112351:case class Board(N: Int, private[Board] val squares: List[List[Boolean]]):\n  def this(squares: List[List[Boolean]]) = this(squares.size, squares)\n  require(squares.length == N && squares.forall(_.length == N))\n  def apply(i: Int)(j: Int): Boolean = squares(i)(j)\nimport scala.collection.mutable.Stack\ntype Point = Coord[Int]\ntype Solution = List[Point]\ntype PartialSolution = Stack[Point]\nimport scala.collection.Seq
1740805119031:class EmptyBoard(n: Int) extends Board(n, List.fill(n)(List.fill(n)(false))):\n  inline override def apply(i: Int)(j: Int): Boolean = false
1740805965846:import scala.util.control.NonLocalReturns.{ returning, throwReturn => thr }\n\nobject Validator:\n\n  def apply(solution: Seq[Point])\n           (using board: Board): Boolean = returning:\n    for\n      n <- 0 until board.N\n      m <- (n + 1) until board.N\n      p = solution(n)\n      q = solution(m)\n    do\n      if false ||\n        p.row == q.row ||\n        p.col == q.col ||\n        p.row - p.col == q.row - q.col ||\n        p.row + p.col == q.row + q.col ||\n        false\n      then\n        thr(false)\n    true
1740806008990:def queens(using M: Long, board: Board): Unit =\n  var maxSolutions = M\n  tqueens(board.N, 0 x 0)(Nil)()\n  def tqueens(k: Int, q: Point)(implicit currentSolution: Solution): Trampoline[Unit] =\n    if q.row == board.N\n    then\n      Done(())\n    else if k == 0\n    then\n      if Validator(currentSolution)\n      then\n        println(currentSolution.sorted)\n        maxSolutions -= 1\n        if maxSolutions == 0\n        then\n          throw MaxSolutionsReached\n      Done(())\n    else if q.col == board.N\n    then\n      Call { tqueens(k, q.row + 1 x 0) }\n    else\n      for\n        _ <- Call { tqueens(k, q.row x q.col + 1) }\n        _ <- Call {\n          if !board(q.row)(q.col)\n          then\n            tqueens(k - 1, q.row x q.col + 1)(currentSolution :+ q)\n          else\n            Done(())\n        }\n      yield\n        ()
1741712020452:given Board = new EmptyBoard(4)
1741712024964:given Long = 2
1741712030740:try queens catch MaxSolutionsReached => ()
