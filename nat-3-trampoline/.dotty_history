1740690779355:import cats._, cats.free.{ Trampoline => CatsTrampoline, _}, cats.arrow._, cats.data._, cats.syntax.all._, cats.instances.all._
1740690784530:import scala.util.control.TailCalls.TailRec
1740732132860:import cats.effect.unsafe.implicits.global, cats.effect.IO
1742066230564:sealed abstract trait Trampoline[A]:\n  import Trampoline._\n\n  def visit[F[_]](v: Visitor[F]): F[A]\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  trait Visitor[F[_]] extends (Trampoline ~> F):\n    final override def apply[A](ta: Trampoline[A]): F[A] = ta.visit(this)\n\n    def done[A](value: A): F[A]\n    final def call[A](closure: Unit => Trampoline[A]): F[A] = fMap(Done(()), closure)\n    def fMap[A, B](self: Trampoline[A], cont: A => Trampoline[B]): F[B]\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  final case class Done[A](value: A) extends Trampoline[A]:\n    override def visit[F[_]](v: Visitor[F]): F[A] = v.done(value)\n\n  final case class Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]:\n    override def visit[F[_]](v: Visitor[F]): F[A] = v.call(closure)\n\n  final case class FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]:\n    override def visit[F[_]](v: Visitor[F]): F[B] = v.fMap(self, sequel)\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)\n\n  object Call:\n    def apply[A](thunk: => Trampoline[A]): Trampoline[A] = Call { _ => thunk }
1740742390036:import Trampoline._
1742064978985:class MonadInterpreter[M[_]](implicit val M: Monad[M]):\n  object TrampolineInterpreter extends Trampoline.Visitor[M]:\n    override def done[A](value: A): M[A] = M.pure(value)\n    override def fMap[A, B](self: Trampoline[A], cont: A => Trampoline[B]): M[B] =\n      M.flatMap(apply(self))(cont andThen apply)
1740742540156:case class Algorithms(n: Int):\n  private def fibonacci(k: Int): Trampoline[Int] =\n    if k < 2\n    then\n      Done(1 min (0 max k))\n    else\n      for\n        m <- Call { fibonacci(k - 2) }\n        n <- Call { fibonacci(k - 1) }\n      yield\n        n + m\n  private def factorial(k: Int): Trampoline[Int] =\n    if k < 1\n    then\n      Done(1)\n    else\n      for\n        n <- Call { factorial(k - 1) }\n      yield\n        k * n\n  def fib: Trampoline[Int] = fibonacci(n)\n  def fac: Trampoline[Int] = factorial(n)
1740742552240:val a = Algorithms(5)
1741323872185:MonadInterpreter[Eval].TrampolineInterpreter.apply(a.fib).value
1741323880857:MonadInterpreter[TailRec].TrampolineInterpreter.apply(a.fib).result
1742062617980:implicitly[Monad[TailRec]]
1741323886601:MonadInterpreter[IO].TrampolineInterpreter.apply(a.fac).unsafeRunSync()
1741323903857:MonadInterpreter[CatsTrampoline].TrampolineInterpreter.apply(a.fac).runTailRec()()
1742065577649:implicit val kittensTrampolineMonadInstance: Monad[Trampoline] =\n  new StackSafeMonad[Trampoline]:\n    //override def ap[A, B](ff: Trampoline[A => B])(fa: Trampoline[A]): Trampoline[B] =\n    //  flatMap(ff)(map(fa)(_))\n    //override def flatten[A](ffa: Trampoline[Trampoline[A]]): Trampoline[A] =\n    //  flatMap(ffa)(identity)\n    override def flatMap[A, B](fa: Trampoline[A])(fun: A => Trampoline[B]): Trampoline[B] =\n      fa.flatMap(fun)\n    //override def map[A, B](fa: Trampoline[A])(fun: A => B): Trampoline[B] =\n    //  fa.map(fun)\n    override def pure[A](a: A): Trampoline[A] = Trampoline.pure(a)
1741332244395:MonadInterpreter[Trampoline].TrampolineInterpreter.apply(a.fac)()
1742135713977:MonadInterpreter[Id].TrampolineInterpreter.apply(a.fib)
