1740772993197:import cats.syntax.all.*
1740773118333:import cats.{ Functor, FlatMap, Monad, StackSafeMonad }
1740773104495:sealed abstract trait Trampoline[+A]:\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  final case class Done[+A](value: A) extends Trampoline[A]\n\n  final case class Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n\n  final case class FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)
1740818926522:enum Trampoline[+A]:\n  case Done[+A](value: A) extends Trampoline[A]\n  case Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n  case FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n  def pure[A](a: A): Trampoline[A] = new Done(a)
1740773549957:implicit val kittensMonadTrampolineInstance: Monad[Trampoline] =\n  new StackSafeMonad[Trampoline]:\n    override def ap[A, B](ff: Trampoline[A => B])(fa: Trampoline[A]): Trampoline[B] =\n      flatMap(ff)(map(fa)(_))\n    override def flatten[A](ffa: Trampoline[Trampoline[A]]): Trampoline[A] =\n      flatMap(ffa)(identity)\n    override def flatMap[A, B](fa: Trampoline[A])(fun: A => Trampoline[B]): Trampoline[B] =\n      fa.flatMap(fun)\n    override def map[A, B](fa: Trampoline[A])(fun: A => B): Trampoline[B] =\n      fa.map(fun)\n    override def pure[A](a: A): Trampoline[A] = Trampoline.pure(a)
1740773120014:object myFunctorSyntax:\n  implicit class Ops[F[_], A](lhs: F[A])(implicit F: Functor[F]):\n    def map[B](rhs: A => B): F[B] =\n      F.map[A, B](lhs)(rhs)
1740773125238:object myFlatMapSyntax:\n  implicit class Ops[F[_], A](lhs: F[A])(implicit F: FlatMap[F]):\n    def flatMap[B](rhs: A => F[B]): F[B] =\n      F.flatMap[A, B](lhs)(rhs)
1740773131412:import myFunctorSyntax.*
1740773135012:import myFlatMapSyntax.*
1740773146261:def test[F[_]](implicit M: Monad[F]) =\n  for\n    x <- M.pure(1)\n    f <- M.pure((_: Int).toDouble)\n    y <- M.pure(2.0)\n  yield\n    f(x) + y
1740773164157:def test[F[_]](using M: Monad[F]): F[Double] =\n   val d = (_: Int).toDouble\n   M.pure(1).flatMap[Double] { (x: Int) =>\n    M.pure(d).flatMap[Double] { (f: d.type) =>\n      M.pure(2.0).map[Double] { (y: Double) =>\n        f(x) + y\n      }\n   }\n}
1741785230302:enum Trampoline[+A]:\n  case Done[+A](value: A) extends Trampoline[A]\n  case Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n  case FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)
1741785242206:sealed abstract trait Trampoline[+A]:\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  final case class Done[+A](value: A) extends Trampoline[A]\n\n  final case class Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n\n  final case class FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)
1741785246054:enum Trampoline[+A]:\n  case Done[+A](value: A) extends Trampoline[A]\n  case Call[A](closure: Unit => Trampoline[A]) extends Trampoline[A]\n  case FlatMap[A, B](self: Trampoline[A], sequel: A => Trampoline[B]) extends Trampoline[B]\n\n  import Trampoline.*\n\n  final def map[B](fun: A => B): Trampoline[B] =\n    this.flatMap(fun andThen pure)\n\n  final def flatMap[B](sequel: A => Trampoline[B]): Trampoline[B] =\n    FlatMap(this, sequel)\n\n  @annotation.tailrec\n  final def apply(): A = this match\n    case Done(value) => value\n    case Call(closure) => closure(())()\n    case FlatMap(Done(value), sequel) => sequel(value)()\n    case FlatMap(Call(closure), sequel) => (closure :: sequel)(())()\n    case FlatMap(FlatMap(self, prequel), sequel) => FlatMap(self, prequel :: sequel)()\n\nobject Trampoline:\n\n  extension [A, B](prequel: A => Trampoline[B])\n    inline def ::[C](sequel: B => Trampoline[C]): A => Trampoline[C] =\n      prequel(_).flatMap(sequel)\n\n  def pure[A](a: A): Trampoline[A] = new Done(a)
1741785251340:import Trampoline.*
1741785258829:implicit val kittensMonadTrampolineInstance: Monad[Trampoline] =\n  new StackSafeMonad[Trampoline]:\n    override def ap[A, B](ff: Trampoline[A => B])(fa: Trampoline[A]): Trampoline[B] =\n      flatMap(ff)(map(fa)(_))\n    override def flatten[A](ffa: Trampoline[Trampoline[A]]): Trampoline[A] =\n      flatMap(ffa)(identity)\n    override def flatMap[A, B](fa: Trampoline[A])(fun: A => Trampoline[B]): Trampoline[B] =\n      fa.flatMap(fun)\n    override def map[A, B](fa: Trampoline[A])(fun: A => B): Trampoline[B] =\n      fa.map(fun)\n    override def pure[A](a: A): Trampoline[A] = Trampoline.pure(a)
1741785267292:import cats.{ Functor, FlatMap, Monad, StackSafeMonad }
1741785271429:implicit val kittensMonadTrampolineInstance: Monad[Trampoline] =\n  new StackSafeMonad[Trampoline]:\n    override def ap[A, B](ff: Trampoline[A => B])(fa: Trampoline[A]): Trampoline[B] =\n      flatMap(ff)(map(fa)(_))\n    override def flatten[A](ffa: Trampoline[Trampoline[A]]): Trampoline[A] =\n      flatMap(ffa)(identity)\n    override def flatMap[A, B](fa: Trampoline[A])(fun: A => Trampoline[B]): Trampoline[B] =\n      fa.flatMap(fun)\n    override def map[A, B](fa: Trampoline[A])(fun: A => B): Trampoline[B] =\n      fa.map(fun)\n    override def pure[A](a: A): Trampoline[A] = Trampoline.pure(a)
1741785401148:Monad[Trampoline].flatMap[Int, Double](Done(1)) { (x: Int) =>\n  Monad[Trampoline].flatMap[Int => Double, Double](Done((_: Int).toDouble)) { (f: Int => Double) =>\n    Monad[Trampoline].map[Double, Double](Done(2.0)) { (y: Double) =>\n      f(x) + y\n    }\n  }\n}
1741785444397:def test[F[_]](using M: Monad[F]): F[Double] =\n   val d = (_: Int).toDouble\n   M.pure(1).flatMap[Double] { (x: Int) =>\n    M.pure(d).flatMap[Double] { (f: d.type) =>\n      M.pure(2.0).map[Double] { (y: Double) =>\n        f(x) + y\n      }\n   }\n}
1741785656948:def test[F[_]](implicit M: Monad[F]) =\n  for\n    x <- M.pure(1)\n    f <- M.pure((_: Int).toDouble)\n    y <- M.pure(2.0)\n  yield\n    f(x) + y
